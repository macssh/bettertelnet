/**    macros.c*	 originally by Gaige B. Paulsen**	NCSA Revisions:*	7/92	Moved here from event.c and maclook.c by JMB*	11/94	Rewritten to use handle based macros JMB*/// BetterTelnet// copyright 1997 Rolf Braun// This is free software under the GNU General Public License (GPL). See the file COPYING// which comes with the source code and documentation distributions for details.// based on NCSA Telnet 2.7b5#ifdef MPW#pragma segment Macros#endif#include "network.proto.h"				/* For netwrite proto */#include "wind.h"				/* For WindRec definition */#include "DlogUtils.proto.h"#include "parse.proto.h"#include "event.proto.h"#include "menuseg.proto.h"#include "vsdata.h"#include "vsinterf.proto.h"#include "macros.proto.h"#include "Sets.proto.h" //for CStringToFile/* Macro Defines */#define MACRO_IP		0xff	/* Send IP number here */#define MACRO_LINES		0xfe	/* Send # of lines here */#define	MACRO_MAX_LEN	256		// Maximum macro lengthextern Cursor *theCursors[];Handle	gMacros[10];void	MACROSunload(void) {}void	initmacros( void){	short i;	for (i=0; i<10 ; i++) {		gMacros[i] = nil;		}}void CheckGlobalMacros(void){	OSErr err;	FSSpec macroFile;	Boolean dummy1, dummy2;	err = FSMakeFSSpec(TelInfo->PrefFolder.vRefNum, TelInfo->PrefFolder.parID, "\pBetterTelnet Macros", &macroFile);	if (!err) {		ResolveAliasFile(&macroFile, FALSE, &dummy1, &dummy2);		loadMacros(&macroFile);	}}void SaveGlobalMacros(void){	OSErr err;	FSSpec macroFile;	Boolean dummy1, dummy2;	err = FSMakeFSSpec(TelInfo->PrefFolder.vRefNum, TelInfo->PrefFolder.parID, "\pBetterTelnet Macros", &macroFile);	if ((!err) || (err == -43)) {		ResolveAliasFile(&macroFile, FALSE, &dummy1, &dummy2);		saveMacros(&macroFile);	}}void	setmacro(short n, char *s)			/* Set macro number <n> to the value of s */{	unsigned char	*p;	short	num, pos, escape;	short	len;	OSErr 	memError;		if (n<0  || n>9)		return;	// Restrict the maximum length of macros to MACRO_MAX_LEN bytes	len = strlen(s)+1;	if (len > (MACRO_MAX_LEN - 1)) {		len = MACRO_MAX_LEN;		s[MACRO_MAX_LEN - 1] = 0;		}		// If this is an empty string, remove whatever storage might have been used previously	// by this macro.	if (len == 1) {		if (gMacros[n] != nil) {			DisposeHandle(gMacros[n]);			gMacros[n] = nil;			}		return;		}			// If neccessary, create storage for the macro	if (gMacros[n] == nil) {		gMacros[n] = myNewHandle(len);		if (gMacros[n] == nil) {		// Memory error			return;			}		}	// Adjust the handle to the proper size (may be making an existing macro longer)	memError = mySetHandleSize(gMacros[n], len);	if (memError != noErr) {		return;		}		HLock(gMacros[n]);	p = (unsigned char *)*gMacros[n];	num = 0;	pos = 0;	escape = 0;		while ( *s) {		if (escape) {			escape = 0;			switch (*s) {				case 'i':					if ( pos >0) {						*p++=num;						*p++=*s;						pos=0;						}					*p++=MACRO_IP;					break;				case '#':					if ( pos >0) {						*p++=num;						*p++=*s;						pos=0;						}					*p++=MACRO_LINES;					break;				case 'n':					if ( pos >0) {						*p++=num;						*p++=*s;						pos=0;						}					*p++='\012';					break;				case 'r':					if ( pos >0) {						*p++=num;						*p++=*s;						pos=0;						}					*p++='\015';					break;				case 't':					if ( pos >0) {						*p++=num;						*p++=*s;						pos=0;						}					*p++='\t';					break;				case '"':					if ( pos >0) {						*p++=num;						*p++=*s;						pos=0;						}					*p++='\"';					break;										case '\\':					if ( pos >0) {						*p++=num;						escape=1;						pos=0;						num=0;						}					else						*p++='\\';					break;				default:					if (*s <='9' && *s >='0' && pos <3) {						num= num*8+( *s -'0');						pos++;						escape=1;						}					else {						if (pos ==0 && num==0) {							*p++='\\';							*p++=*s;							}						else {							*p++=num;							pos= 0;							s--;			/* back up the buffer. */							}						}					break;				}			}		else {			if (*s=='\\') {				num=0;				pos=0;				escape=1;				}			else				*p++=*s;			}		s++;		}	if (pos >0) *p++=num;		*p=0;		// The resultant macro may be shorter than the input string due to escaped characters.	// So, recalculate the length of the macro and resize than handle if neccessary.	len = strlen(*gMacros[n])+1;		HUnlock(gMacros[n]);	mySetHandleSize(gMacros[n], len);} /* setmacro */short	sendmacro(struct WindRec *tw, short n)				/* send macro number n */{	char			temp[20];	unsigned char	*mp, *first;	unsigned char	myipnum[4];		// Invalid number	if (n<0 || n>9) {		return -1;		}		// Empty macro, so do nothing	if (gMacros[n] == nil) {		return 0;		}		HLock(gMacros[n]);	mp = (unsigned char *)*gMacros[n];	first = mp;		netgetip(myipnum);	while ( *mp) {		if (*mp==MACRO_IP) {			SendStringAsIfTyped(tw, (char *)first, mp-first);			sprintf(temp,"%d.%d.%d.%d", myipnum[0], myipnum[1], myipnum[2], myipnum[3]);			SendStringAsIfTyped(tw, temp, strlen(temp));			first = mp+1;			}		else if ( *mp==MACRO_LINES) {			SendStringAsIfTyped(tw, (char *)first, mp-first);			sprintf(temp,"%d", VSgetlines(tw->vs));			SendStringAsIfTyped(tw, temp, strlen(temp));			first = mp+1;			}		mp++;		}	SendStringAsIfTyped(tw, (char *)first, mp-first);	HUnlock(gMacros[n]);	return 0;}short	getmacro(short n, char *dest, short room){	unsigned char	*s;	// Invalid number	if (n<0 || n>9) {		return -1;		}		// Empty macro, so return empty string	if (gMacros[n] == nil) {		*dest = 0;		return 0;		}			s = (unsigned char *)*gMacros[n];		while (*s && (room >= 5)) {  // 5 = (size of \xxx) + (terminating \0)		switch( *s) {			case MACRO_IP :				*dest++='\\';				*dest++='i';				room--;				break;			case MACRO_LINES :				*dest++='\\';				*dest++='#';				room--;				break;			case '\\':				*dest++='\\';				*dest++='\\';				room--;				break;			case '\015':				*dest++='\\';				*dest++='r';				room--;				break;			case '\012':				*dest++='\\';				*dest++='n';				room--;				break;			case '\t':				*dest++='\\';				*dest++='t';				room--;				break;			default: 				if ( isprint(*s)) 					*dest++=*s;				else {					*dest++='\\';					*dest++= (*s / 64) +'0';					*dest++= ((*s % 64) / 8)+'0';					*dest++= (*s % 8) +'0';					room = room - 3;					}				break;			}		room--;		s++;		}	*dest = 0;	return( 0);}void	Macros( void){	DialogPtr dtemp;	short dItem;	short i;	Rect dBox;	Str255 temp;	Handle MacString[10];	SetCursor(theCursors[normcurs]);	if (TelInfo->macrosModeless) {		SelectWindow(TelInfo->macrosModeless);		return;	}	dtemp=GetNewMyDialog( MacroDLOG, NULL, kInFront, (void *)ThirdCenterDialog);	SetDialogDefaultItem(dtemp, 1);	SetDialogCancelItem(dtemp, 2);	SetDialogTracksCursor(dtemp, 1);	for (i=0; i<10; i++) {		getmacro(i, (char *) &temp, 256);		/* BYU LSC */		c2pstr((char *)temp);								/* BYU LSC */		GetDItem( dtemp, i+13, &dItem, &MacString[i], &dBox);		SetIText( MacString[i], temp );		}	TelInfo->macrosModeless = dtemp;}void MacroDialog(EventRecord *theEvent, short dItem){	DialogPtr dtemp;	short i;	Rect dBox;	Str255 temp;	Handle MacString[10];	dtemp = TelInfo->macrosModeless;	switch (dItem) {		case (MacroExport):			for (i=0; i<10; i++) {				GetDItem( dtemp, i+13, &dItem, &MacString[i], &dBox);				GetIText( MacString[i], temp);				p2cstr(temp);				setmacro(i, (char *) &temp);			}			saveMacros((FSSpec *) NULL);			break;		case 25:			for (i=0; i<10; i++) {				GetDItem( dtemp, i+13, &dItem, &MacString[i], &dBox);				GetIText( MacString[i], temp);				p2cstr(temp);				setmacro(i, (char *) &temp);			}			SaveGlobalMacros();			break;		case (MacroImport):			loadMacros((FSSpec *) NULL);			for (i=0; i<10; i++) {				getmacro(i, (char *) &temp, 256);						c2pstr((char *)temp);												GetDItem( dtemp, i+13, &dItem, &MacString[i], &dBox);				SetIText( MacString[i], temp );			}			break;		case 1:			updateCursor(1);			CloseMacros();			break;		case 2:			updateCursor(1);			DisposeDialog(dtemp);			TelInfo->macrosModeless = 0;			AdjustMenus();			DoTheMenuChecks();			break;		default:			if (dItem >2 && dItem <13) 			{				i=dItem-3;				getmacro( i, (char *) &temp, 256);			/* BYU LSC */				c2pstr((char *)temp);				GetDItem( dtemp, i+13, &dItem, &MacString[i], &dBox);				SetIText( MacString[i], temp );				/* BYU LSC - Revert the mother */				SelIText( dtemp, i+13, 0, 32767);				/* And select it... */			}				break;	}}void CloseMacros(void){	DialogPtr dtemp;	short dItem;	short i;	Rect dBox;	Str255 temp;	Handle MacString[10];	dtemp = TelInfo->macrosModeless;	for (i=0; i<10; i++) {		GetDItem( dtemp, i+13, &dItem, &MacString[i], &dBox);		GetIText( MacString[i], temp);		p2cstr(temp);		setmacro(i, (char *) &temp);		}	DisposeDialog(TelInfo->macrosModeless);	TelInfo->macrosModeless = 0;	AdjustMenus();	DoTheMenuChecks();}void saveMacros(FSSpec *theFile){	SFReply		whereReply;	short 		refNum,exist;	FSSpec		macroFile;	long		junk;	short 		i;	char		temp[256], temp2[256];	Point		where;	OSErr		err;	Str255		tempString,tempString2;	where.h = 100; where.v = 100;	GetIndString(tempString,MISC_STRINGS,SAVE_MACROS_STRING);	GetIndString(tempString2,MISC_STRINGS,DEFAULT_MACRO_SET_NAME);	if (theFile == 0) {		SFPutFile( where, tempString, tempString2, 0L, &whereReply);		if (!whereReply.good)			return;		BlockMoveData(&whereReply.fName, macroFile.name, (*whereReply.fName)+1); 		GetWDInfo(whereReply.vRefNum, &macroFile.vRefNum, &macroFile.parID, &junk);	}	else		macroFile = *theFile;	if ((err = HCreate(macroFile.vRefNum, macroFile.parID, 			macroFile.name, kNCSACreatorSignature, 'TEXT')) == dupFNErr)		exist = 1;		err = HOpenDF(macroFile.vRefNum, macroFile.parID, macroFile.name, fsWrPerm, &refNum);	if (exist) 		SetEOF(refNum, 0L);		for (i = 0; i < 10; i++)	{		getmacro(i, temp, sizeof(temp));					sprintf(temp2, "key%d = \"", i);				CStringToFile(refNum,(unsigned char *) temp2);		if (*temp) 		{												CStringToFile(refNum,(unsigned char *) temp);		}		strcpy(temp2,"\"\015");		CStringToFile(refNum,(unsigned char *) temp2);		}	FSClose(refNum);	}void loadMacros(FSSpec *theFile){	SFReply		sfr;	long		junk;	SFTypeList	typesok = {'TEXT'};	Point		where;	FSSpec		macros;	OSErr 		err;	short 		fileRef;	where.h=100;where.v=100;	if (theFile == 0L)	{		SFGetFile( where, NULL, 0L, 1, typesok, 0L, &sfr);		if (!sfr.good) return;		BlockMove(&sfr.fName, macros.name, (*sfr.fName)+1); 		GetWDInfo(sfr.vRefNum, &macros.vRefNum, &macros.parID, &junk);		err = HOpenDF(macros.vRefNum, macros.parID, macros.name, fsRdPerm, &fileRef);	}	else		err = HOpenDF(theFile->vRefNum, theFile->parID, theFile->name, fsRdPerm, &fileRef);		if (err != noErr)		return;		parseMacroFile(fileRef);	FSClose(fileRef);}void parseMacroFile(short fileRef){	unsigned char buffer[300],*bufferPtr;	unsigned char newMacro[256], *newMacroPtr;	OSErr fileErr = noErr;	short numMacrosRead = 0;	short totalLen,i;	long count=1;	bufferPtr = buffer; 	for(i = 0; i < 10; i++)	{		if (gMacros[i] != NULL)			DisposHandle(gMacros[i]);	}	initmacros();  //sets all handles to null	while ((fileErr != eofErr)&&(numMacrosRead < 10))	{		fileErr = FSRead(fileRef,&count,bufferPtr);		while((*bufferPtr != 0x0D)&&(fileErr != eofErr))	//while not CR or EOF		{					++bufferPtr;			fileErr = FSRead(fileRef,&count,bufferPtr);				}				totalLen = bufferPtr-buffer;		bufferPtr = buffer;		newMacroPtr = newMacro;		while((*bufferPtr++ != '"')&&(totalLen != 0))			--totalLen;		while((*bufferPtr != '"')&&(totalLen != 0))		{			*newMacroPtr++ = *bufferPtr++;			--totalLen;		}				*newMacroPtr = NULL; //make this a C string		setmacro(numMacrosRead,(char *)newMacro);		bufferPtr = buffer;		++numMacrosRead;	}}